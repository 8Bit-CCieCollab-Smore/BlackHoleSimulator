<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2D Black Hole Simulator ‚Äî Canvas 2D (single file)</title>
<style>
  :root{
    --bg0:#0c0b12; --bg1:#161427; --bg2:#25244a; --bg3:#3a4372; --bg4:#5e6aa0;
    --panel:#0d1022cc; --text:#eef2ff; --muted:#aab2d6; --accent:#87d2ff; --accent2:#b18cff;
  }
  html,body{margin:0;height:100%;background:#0a0b12;color:var(--text);font:14px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #wrap{position:fixed;inset:0}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  #ui{position:absolute;top:12px;left:12px;width:320px;max-height:88vh;overflow:auto;
      background:var(--panel);backdrop-filter:blur(6px);border:1px solid #1b2140;border-radius:16px;
      box-shadow:0 10px 30px #0008;padding:12px}
  #ui h1{font-size:16px;margin:0 0 8px}
  #ui .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
  #ui .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  button{background:#1a1f39;color:var(--text);border:1px solid #2a3260;border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{border-color:#3b4890}
  label{color:var(--muted)}
  small{color:var(--muted)}
  #fps{color:var(--muted)}
  .nameTag{position:absolute;pointer-events:none;color:#eef2ff;text-shadow:0 0 6px #000,0 0 12px #000;font-weight:600}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="ui">
    <h1>üåÄ Black Hole + Gravity (2D)</h1>
    <div class="grid">
      <button id="addBH">+ Black Hole</button>
      <button id="addStar">+ Star</button>
      <button id="addPlanet">+ Planet</button>
      <button id="addSolar">‚òÄÔ∏è Solar System</button>
      <button id="clear">üßπ Clear</button>
      <button id="reset">‚ôªÔ∏è Reset View</button>
    </div>

    <div class="row"><label>Gravity G: <b id="gVal"></b></label><input id="g" type="range" min="0.1" max="2.0" step="0.001"></div>
    <div class="row"><label>Time Scale: <b id="tsVal"></b></label><input id="ts" type="range" min="0.2" max="2.5" step="0.01"></div>
    <div class="row"><label>Tidal Strength: <b id="tidVal"></b></label><input id="tid" type="range" min="0.2" max="3.0" step="0.01"></div>
    <div class="row"><label>Trails</label><input id="trails" type="checkbox"></div>
    <div class="row"><label>Labels</label><input id="labels" type="checkbox" checked></div>
    <div class="row"><label>Max Bodies: <b id="mbVal"></b></label><input id="maxb" type="range" min="10" max="300" step="10"></div>
    <div class="row"><small>Shift+Drag a body to move it ‚Ä¢ Scroll over a body to adjust mass</small></div>
    <div class="row"><span id="fps">FPS</span></div>
  </div>
</div>

<script>
(() => {
  // ========= Canvas & DPI =========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=0, H=0, CX=0, CY=0;

  const bg = document.createElement('canvas'); // stable background layer
  const bgctx = bg.getContext('2d');

  function resize(){
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    bg.width = W; bg.height = H;
    drawStableBackground();

    CX=W/2; CY=H/2;
  }
  window.addEventListener('resize', resize);

  // ========= Names / Colors =========
  const NAME = {
    systems: ["Solar","Alpha Centauri","TRAPPIST-1","Kepler-90","Kepler-11","HD 219134","TOI-700","Gliese 581","KIC 8462852","LHS 1140"],
    stars:   ["Sun","Sirius","Proxima","Betelgeuse","Rigel","Vega","Altair","Deneb","Arcturus","Polaris","Tau Ceti","Epsilon Eridani","Kepler-452"],
    planets: ["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Kepler-186f","Kepler-22b","Kepler-62f","Proxima b","TRAPPIST-1e","LHS 1140 b","Gliese 581g","HD 209458 b","WASP-12b","K2-18b"],
    blackholes: ["Sagittarius A*","M87*","Cygnus X-1","LMC X-3","NGC 1277*","GRO J1655-40","A0620-00","V404 Cygni","M60-UCD1*","TON 618"]
  };
  const TYPE = { BH:'bh', STAR:'star', PLANET:'planet' };
  const rand=(a=0,b=1)=>a+Math.random()*(b-a);
  const TAU=Math.PI*2;
  const clamp=(v,a,b)=>v<a?a:v>b?b:v;

  const planetPalette = ['#8fd3ff','#9ae6b4','#eab1ff','#ffd6a5','#c0b6ff','#a1f0ff','#ffadbc','#9cffd1','#d1ffe2','#c6f7ff'];
  const starPalette   = ['#ffd07a','#fff3c2','#ffe3a1','#d6e6ff','#ffdcdc'];

  function randomName(type){
    if(type===TYPE.BH) return NAME.blackholes[(Math.random()*NAME.blackholes.length)|0];
    if(type===TYPE.STAR) return NAME.stars[(Math.random()*NAME.stars.length)|0];
    return NAME.planets[(Math.random()*NAME.planets.length)|0];
  }
  function pickColor(type){
    if(type===TYPE.BH) return '#9be1ff';
    if(type===TYPE.STAR) return starPalette[(Math.random()*starPalette.length)|0];
    return planetPalette[(Math.random()*planetPalette.length)|0];
  }

  // ========= Background (static, no crazy motion) =========
  function drawStableBackground(){
    const g = bgctx.createRadialGradient(W*0.65,H*0.35, 40, W*0.5,H*0.5, Math.hypot(W,H)*0.9);
    g.addColorStop(0.00, '#3f3a6b'); // muted purple
    g.addColorStop(0.35, '#2b2f56'); // indigo/blue
    g.addColorStop(0.72, '#171a2a'); // deep gray-blue
    g.addColorStop(1.00, '#0b0c13'); // near black
    bgctx.fillStyle=g; bgctx.fillRect(0,0,W,H);

    // very faint, still stars (no movement)
    bgctx.save();
    bgctx.globalAlpha=0.28;
    bgctx.fillStyle='#cfd7ff';
    for(let i=0;i<220;i++){
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0, r=Math.random()*1.2;
      bgctx.beginPath(); bgctx.arc(x,y,r,0,TAU); bgctx.fill();
    }
    bgctx.restore();
  }

  // ========= Physics =========
  const params = {
    G: 0.6,
    dtScale: 1.0,
    tidalK: 1.25,   // visual spaghettification strength
    drawTrails: false,
    drawLabels: true,
    maxBodies: 150
  };

  const bodies = [];             // dynamic bodies
  const trails = [];             // per-body trail
  const MAX_TRAIL = 80;

  function radiusFromMass(m, type){
    if(type===TYPE.BH)   return Math.max(4, Math.sqrt(m)/10);   // pseudo Schwarzschild scale
    if(type===TYPE.STAR) return Math.max(2, Math.pow(m,0.35));
    return Math.max(2, Math.pow(m,0.33));
  }

  function makeBody(type, opts={}){
    const b = {
      id: Math.random().toString(36).slice(2),
      type,
      x: opts.x ?? rand(W*0.25, W*0.75),
      y: opts.y ?? rand(H*0.25, H*0.75),
      vx: opts.vx ?? rand(-30,30),
      vy: opts.vy ?? rand(-30,30),
      m:  opts.m ?? (type===TYPE.BH ? rand(2e4, 8e4) : type===TYPE.STAR ? rand(3e3, 1.5e4) : rand(50,700)),
      r:  0,
      name: opts.name ?? randomName(type),
      color: opts.color ?? pickColor(type),
      acc: {x:0,y:0},
      locked:false,
      fading:false, fadeT:0 // for accretion dissolve
    };
    b.r = radiusFromMass(b.m, type);
    bodies.push(b); trails.push([]);
    return b;
  }

  function gravityStep(dt){
    // Reset accelerations
    for(const b of bodies){ b.acc.x=0; b.acc.y=0; }

    // Pairwise forces; collect merges to apply after
    const toMerge = []; // [eaterIndex, foodIndex]
    for(let i=0;i<bodies.length;i++){
      const bi = bodies[i];
      for(let j=i+1;j<bodies.length;j++){
        const bj = bodies[j];
        const dx=bj.x-bi.x, dy=bj.y-bi.y;
        const d2=dx*dx+dy*dy + 25; // softening
        const d=Math.sqrt(d2);
        const f = params.G*bi.m*bj.m/d2;
        const fx = f*dx/d, fy=f*dy/d;
        bi.acc.x += fx/bi.m; bi.acc.y += fy/bi.m;
        bj.acc.x -= fx/bj.m; bj.acc.y -= fy/bj.m;

        // Accretion criterion (BH eats when inside horizon)
        if((bi.type===TYPE.BH || bj.type===TYPE.BH) && d < Math.max(bi.r,bj.r)*0.85){
          const eater = (bi.type===TYPE.BH) ? i : j;
          const food  = (bi.type===TYPE.BH) ? j : i;
          toMerge.push([eater,food]);
        }
      }
    }

    // Integrate
    for(const b of bodies){
      b.vx += b.acc.x * dt;
      b.vy += b.acc.y * dt;
      if(!b.locked){ b.x += b.vx * dt; b.y += b.vy * dt; }

      // Edge behavior: wrap
      if(b.x<0) b.x+=W; if(b.x>W) b.x-=W;
      if(b.y<0) b.y+=H; if(b.y>H) b.y-=H;
    }

    // Apply merges AFTER forces/integration to avoid freeze
    if(toMerge.length){
      // sort unique foods to remove safely
      const foods = new Set(toMerge.map(p=>p[1]));
      // merge each pair
      for(const [ei,fi] of toMerge){
        const eater = bodies[ei], food = bodies[fi];
        if(!eater || !food) continue; // already merged
        if(eater === food) continue;
        const totalM = eater.m + food.m;
        eater.vx = (eater.vx*eater.m + food.vx*food.m)/totalM;
        eater.vy = (eater.vy*eater.m + food.vy*food.m)/totalM;
        eater.m = totalM;
        eater.r = radiusFromMass(eater.m, eater.type);
        // mark food to dissolve
        food.fading = true;
        food.fadeT = 0;
      }
      // actually remove faded ones a bit later in render
    }
  }

  // ========= Rendering helpers =========
  // Name tags
  const labelNodes = new Map();
  function drawLabel(b){
    if(!params.drawLabels) return;
    let n = labelNodes.get(b.id);
    if(!n){ n=document.createElement('div'); n.className='nameTag'; document.body.appendChild(n); labelNodes.set(b.id,n); }
    n.textContent = `${b.name} (${b.type})`;
    n.style.left = (b.x + 8) + 'px';
    n.style.top  = (b.y - b.r - 14) + 'px';
    n.style.display='block';
  }
  function hideUnusedLabels(){
    const alive = new Set(bodies.map(b=>b.id));
    for(const [id,node] of labelNodes){
      if(!alive.has(id)) { node.remove(); labelNodes.delete(id); }
    }
    if(!params.drawLabels){ for(const node of labelNodes.values()) node.style.display='none'; }
  }

  // Trails
  function pushTrail(i){
    if(!params.drawTrails) { trails[i].length=0; return; }
    const t = trails[i];
    t.push([bodies[i].x, bodies[i].y]);
    if(t.length>MAX_TRAIL) t.shift();
    ctx.save(); ctx.globalAlpha=0.6; ctx.lineWidth=1.2; ctx.strokeStyle=bodies[i].color;
    ctx.beginPath();
    for(let k=0;k<t.length;k++){ const p=t[k]; if(k===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); }
    ctx.stroke(); ctx.restore();
  }

  // Fake lensing: draw magnified annulus from background around BH
  function drawBHLensing(bh){
    const r = bh.r;
    const inner = r*1.05;
    const outer = r*2.2;

    // Clip to annulus
    ctx.save();
    ctx.beginPath();
    ctx.arc(bh.x,bh.y, outer, 0, TAU);
    ctx.arc(bh.x,bh.y, inner, 0, TAU, true);
    ctx.clip('evenodd');

    // Sample a slightly larger src rect and draw scaled to annulus
    // Use background canvas as source (static)
    const sx = Math.max(0, bh.x - outer*1.2),
          sy = Math.max(0, bh.y - outer*1.2),
          sw = Math.min(W - sx, outer*2.4),
          sh = Math.min(H - sy, outer*2.4);

    // Draw a few concentric scaled passes to hint at refraction gradient
    for(let i=0;i<3;i++){
      const scale = 1.06 + i*0.06; // stronger toward outer rim
      const dx = bh.x - (sw*scale)/2;
      const dy = bh.y - (sh*scale)/2;
      ctx.globalAlpha = 0.44 - i*0.12;
      ctx.drawImage(bg, sx,sy,sw,sh, dx,dy, sw*scale, sh*scale);
    }
    ctx.restore();

    // Event horizon
    ctx.fillStyle='#000000';
    ctx.beginPath(); ctx.arc(bh.x,bh.y, r, 0, TAU); ctx.fill();

    // Thin photon ring highlight
    ctx.strokeStyle = '#9be1ff';
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(bh.x,bh.y, r*1.03, 0, TAU); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Spaghettification deformation factor toward a BH
  function spaghettiFactor(body){
    // find strongest BH influence
    let best=0, dirX=0, dirY=0, lens=null;
    for(const b of bodies){
      if(b.type!==TYPE.BH || b===body) continue;
      const dx=b.x-body.x, dy=b.y-body.y;
      const d=Math.hypot(dx,dy);
      const s = (b.m / (d*d+1)) || 0;
      if(s>best){ best=s; dirX=dx/d; dirY=dy/d; lens=b; }
    }
    if(!lens) return {s:1, a:0, ex:1, ey:1, dir:[1,0]};
    // visual tidal factor
    const t = clamp(params.tidalK * best * 1200, 1, 3.5); // max elongation ~3.5x
    const squash = 1/Math.sqrt(t);
    // angle along radial direction
    const a = Math.atan2(dirY,dirX);
    return {s:t, a, ex:t, ey:squash, dir:[dirX,dirY]};
  }

  // Draw bodies with deformation and fading
  function drawBodies(dt){
    const removeIdx = [];
    for(let i=0;i<bodies.length;i++){
      const b = bodies[i];

      // Trails first (behind)
      pushTrail(i);

      if(b.type===TYPE.BH){
        drawBHLensing(b);
        drawLabel(b);
        continue;
      }

      // Planets / Stars
      const deform = spaghettiFactor(b);
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(deform.a);
      ctx.scale(deform.ex, deform.ey);

      // fading on accretion
      let alpha = 1;
      if(b.fading){
        b.fadeT += dt*1.6;
        alpha = clamp(1 - b.fadeT, 0, 1);
        if(alpha<=0){ removeIdx.push(i); ctx.restore(); continue; }
      }
      ctx.globalAlpha = alpha;

      if(b.type===TYPE.STAR){
        const r=b.r;
        const grd = ctx.createRadialGradient(0,0, r*0.3, 0,0, r*1.9);
        grd.addColorStop(0, '#fff6d6');
        grd.addColorStop(0.2, b.color);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(0,0,r*1.9,0,TAU); ctx.fill();
        ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.arc(0,0,r*0.8,0,TAU); ctx.fill();
      } else {
        const r=b.r;
        ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(0,0,r,0,TAU); ctx.fill();
        ctx.globalAlpha=alpha*0.6; ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(-r*0.3,-r*0.3, r*0.3, 0, TAU); ctx.fill();
      }
      ctx.restore();
      drawLabel(b);
    }

    // Remove fully faded bodies (from accretion)
    if(removeIdx.length){
      // remove highest indices first
      removeIdx.sort((a,b)=>b-a);
      for(const idx of removeIdx){
        const dead = bodies[idx];
        bodies.splice(idx,1);
        trails.splice(idx,1);
        const node = labelNodes.get(dead.id);
        if(node){ node.remove(); labelNodes.delete(dead.id); }
      }
    }
  }

  // ========= Interaction =========
  let mouse = {down:false,x:0,y:0,shift:false};
  canvas.addEventListener('pointerdown', e=>{
    mouse.down=true; mouse.x=e.clientX; mouse.y=e.clientY; mouse.shift=e.shiftKey;
    if(mouse.shift){
      // lock nearest body
      let best=null,bd=1e9;
      for(const b of bodies){
        const d=(b.x-mouse.x)**2+(b.y-mouse.y)**2;
        if(d<bd && Math.sqrt(d)<Math.max(20,b.r+18)){ bd=d; best=b; }
      }
      if(best){ best.locked=true; best.vx=0; best.vy=0; best.x=mouse.x; best.y=mouse.y; canvas.setPointerCapture(e.pointerId); }
    }
  });
  canvas.addEventListener('pointermove', e=>{
    mouse.x=e.clientX; mouse.y=e.clientY; mouse.shift=e.shiftKey;
    if(!mouse.down) return;
    if(mouse.shift){
      for(const b of bodies){ if(b.locked){ b.x=mouse.x; b.y=mouse.y; } }
    }
  });
  canvas.addEventListener('pointerup', ()=>{
    mouse.down=false; for(const b of bodies) b.locked=false;
  });
  canvas.addEventListener('wheel', e=>{
    let best=null,bd=1e9;
    for(const b of bodies){
      const d=(b.x-e.clientX)**2+(b.y-e.clientY)**2;
      if(d<bd){bd=d; best=b;}
    }
    if(best){
      best.m = clamp(best.m * (e.deltaY<0 ? 1.08 : 0.925), 10, 1e7);
      best.r = radiusFromMass(best.m, best.type);
    }
    e.preventDefault();
  }, {passive:false});

  // ========= UI =========
  function $(id){return document.getElementById(id)}
  $('g').value=params.G; $('ts').value=params.dtScale; $('tid').value=params.tidalK;
  $('trails').checked=params.drawTrails; $('labels').checked=params.drawLabels;
  $('maxb').value=params.maxBodies;

  const syncVals=()=>{
    $('gVal').textContent=params.G.toFixed(3);
    $('tsVal').textContent=params.dtScale.toFixed(2);
    $('tidVal').textContent=params.tidalK.toFixed(2);
    $('mbVal').textContent=params.maxBodies;
  }; syncVals();

  $('g').oninput=e=>{ params.G=parseFloat(e.target.value); syncVals(); };
  $('ts').oninput=e=>{ params.dtScale=parseFloat(e.target.value); syncVals(); };
  $('tid').oninput=e=>{ params.tidalK=parseFloat(e.target.value); syncVals(); };
  $('trails').onchange=e=>{ params.drawTrails=e.target.checked; };
  $('labels').onchange=e=>{ params.drawLabels=e.target.checked; if(!params.drawLabels){ for(const node of labelNodes.values()) node.style.display='none'; } };
  $('maxb').oninput=e=>{ params.maxBodies=parseInt(e.target.value,10); syncVals(); };
  $('clear').onclick=()=>{ bodies.length=0; trails.length=0; for(const n of labelNodes.values()) n.remove(); labelNodes.clear(); };
  $('reset').onclick=()=>{ resize(); };

  $('addBH').onclick=()=> {
    if(bodies.length>=params.maxBodies) return;
    makeBody(TYPE.BH,{x:rand(W*0.35,W*0.65),y:rand(H*0.35,H*0.65),m:rand(3e4,9e4),vx:0,vy:0});
  };
  $('addStar').onclick=()=> {
    if(bodies.length>=params.maxBodies) return;
    makeBody(TYPE.STAR,{m:rand(5e3,1.2e4)});
  };
  $('addPlanet').onclick=()=> {
    if(bodies.length>=params.maxBodies) return;
    makeBody(TYPE.PLANET,{m:rand(80,1200)});
  };
  $('addSolar').onclick=()=> {
    const cx = rand(W*0.35,W*0.65), cy = rand(H*0.35,H*0.65);
    const star = makeBody(TYPE.STAR,{x:cx,y:cy,m:rand(9e3,1.5e4),vx:0,vy:0,name:NAME.systems[(Math.random()*NAME.systems.length)|0]+' ‚òÄ'});
    const Np=7;
    for(let i=0;i<Np;i++){
      const a=rand(0,TAU), R=60+i*40+rand(-10,10);
      const vmag = Math.sqrt(params.G*star.m/Math.max(R,10));
      const x = cx + Math.cos(a)*R, y = cy + Math.sin(a)*R;
      const vx = -Math.sin(a)*vmag, vy = Math.cos(a)*vmag;
      makeBody(TYPE.PLANET,{x,y,m:rand(90,1200),vx,vy,color:pickColor(TYPE.PLANET), name:randomName(TYPE.PLANET)});
    }
  };

  // ========= Main Loop =========
  let last=performance.now(), fpsAcc=0,fpsCount=0;
  function step(now){
    const dt = ((now-last)/1000) * params.dtScale; last=now;

    gravityStep(dt);

    // Draw
    ctx.drawImage(bg,0,0);     // calm background
    drawBodies(dt);
    hideUnusedLabels();

    // FPS
    fpsAcc+=dt; fpsCount++;
    if(fpsAcc>=0.5){
      const fps = (fpsCount/fpsAcc)|0;
      $('fps').textContent = `FPS: ${fps} ‚Ä¢ Bodies: ${bodies.length}`;
      fpsAcc=0; fpsCount=0;
    }

    requestAnimationFrame(step);
  }

  // ========= Bootstrap =========
  resize();               // IMPORTANT: scene starts EMPTY
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
