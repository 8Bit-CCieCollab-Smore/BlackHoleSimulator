<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2D Black Hole Sandbox - Part 1</title>
<style>
  body { margin: 0; overflow: hidden; background: #888; font-family: Arial; }
  canvas { display: block; }
  #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; color: white; }
  #ui button, #ui label { display: block; margin-top: 5px; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
  <button id="addBlackHole">Add Black Hole</button>
  <button id="addAlien">Add Alien</button>
  <label>Black Hole Mass: <input type="range" id="bhMass" min="500" max="5000" value="1000"></label>
  <label>Alien Mass: <input type="range" id="alienMass" min="1" max="10" value="3"></label>
  <label>Gravity Strength: <input type="range" id="grav" min="0.1" max="5" step="0.1" value="1"></label>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function lerp(a,b,t){ return a + (b-a)*t; }
const floorHeight = 100;

class BlackHole {
  constructor(x,y,mass){ this.x=x; this.y=y; this.mass=mass; this.r=30; this.dragged=false; this.target=null; }
  update(){ if(this.dragged && this.target){ this.x=lerp(this.x,this.target.x,0.05); this.y=lerp(this.y,this.target.y,0.05); } }
  draw(){ const gradient=ctx.createRadialGradient(this.x,this.y,this.r/2,this.x,this.y,this.r*3);
    gradient.addColorStop(0,'black'); gradient.addColorStop(1,'rgba(50,0,100,0.6)');
    ctx.fillStyle=gradient; ctx.beginPath(); ctx.arc(this.x,this.y,this.r*3,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();
  }
}

class Alien{
  constructor(x,y,mass){
    this.x = x; this.y = canvas.height - floorHeight - 50;
    this.vx = 0; this.vy = 0; this.mass = mass; this.dragged = false; this.target = null;
    this.parts = {
      head: {x:this.x,y:this.y-20,r:5,vx:0,vy:0},
      torso: {x:this.x,y:this.y},
      leftArm: {x:this.x-15,y:this.y-5,vx:0,vy:0},
      rightArm: {x:this.x+15,y:this.y-5,vx:0,vy:0},
      leftLeg: {x:this.x-7,y:this.y+20,vx:0,vy:0},
      rightLeg: {x:this.x+7,y:this.y+20,vx:0,vy:0}
    };
  }

  update(bhs){
    const floorY = canvas.height - floorHeight;
    if(this.dragged && this.target){ const dx=this.target.x-this.x, dy=this.target.y-this.y; this.vx=dx*0.2; this.vy=dy*0.2; }
    else this.vy += 0.5;

    for(let bh of bhs){
      const dx=bh.x-this.x, dy=bh.y-this.y; const d2=dx*dx+dy*dy; const dist=Math.sqrt(d2);
      const G=parseFloat(document.getElementById('grav').value); const f=G*bh.mass*this.mass/(d2+1);
      this.vx+=dx/dist*f*0.01; this.vy+=dy/dist*f*0.01;
      if(dist<bh.r*1.5){ this.spag=bhs.indexOf(bh); }
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.y > floorY){ this.y = floorY; this.vy *= -0.2; }

    const stiffness = 0.1, damping = 0.7;
    this.parts.head.vx += (this.x - this.parts.head.x)*stiffness; this.parts.head.vy += (this.y-20 - this.parts.head.y)*stiffness;
    this.parts.head.vx *= damping; this.parts.head.vy *= damping;
    this.parts.head.x += this.parts.head.vx; this.parts.head.y += this.parts.head.vy;

    for(let arm of ['leftArm','rightArm']){
      let p = this.parts[arm];
      let targetX = this.x + (arm==='leftArm'?-15:15), targetY = this.y-5;
      p.vx += (targetX - p.x)*stiffness; p.vy += (targetY - p.y)*stiffness; p.vx *= damping; p.vy *= damping;
      p.x += p.vx; p.y += p.vy;
    }

    for(let leg of ['leftLeg','rightLeg']){
      let p = this.parts[leg];
      let targetX = this.x + (leg==='leftLeg'?-7:7), targetY = this.y+20;
      p.vx += (targetX - p.x)*stiffness; p.vy += (targetY - p.y)*stiffness; p.vx *= damping; p.vy *= damping;
      p.x += p.vx; p.y += p.vy;
    }
    this.parts.torso.x = this.x; this.parts.torso.y = this.y;
  }

  draw(){
    ctx.strokeStyle='green'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(this.parts.torso.x,this.parts.torso.y); ctx.lineTo(this.parts.head.x,this.parts.head.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(this.parts.torso.x,this.parts.torso.y); ctx.lineTo(this.parts.leftArm.x,this.parts.leftArm.y);
    ctx.moveTo(this.parts.torso.x,this.parts.torso.y); ctx.lineTo(this.parts.rightArm.x,this.parts.rightArm.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(this.parts.torso.x,this.parts.torso.y); ctx.lineTo(this.parts.leftLeg.x,this.parts.leftLeg.y);
    ctx.moveTo(this.parts.torso.x,this.parts.torso.y); ctx.lineTo(this.parts.rightLeg.x,this.parts.rightLeg.y); ctx.stroke();
    ctx.fillStyle='lime'; ctx.beginPath(); ctx.arc(this.parts.head.x,this.parts.head.y,this.parts.head.r,0,Math.PI*2); ctx.fill();
  }
}

const blackHoles=[]; const aliens=[]; let mouse={x:0,y:0,down:false,dragging:null};

function drawGrid(){
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1; const step=50;
  for(let x=0;x<canvas.width;x+=step){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
  for(let y=0;y<canvas.height-step;y+=step){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
  ctx.fillStyle='rgba(100,100,100,0.6)'; ctx.fillRect(0,canvas.height-floorHeight,canvas.width,floorHeight);
}
const blackHoles=[]; 
const aliens=[]; 
let mouse={x:0,y:0,down:false,dragging:null};

function drawGrid(){
  ctx.strokeStyle='rgba(0,0,0,0.2)'; 
  ctx.lineWidth=1; 
  const step=50;
  for(let x=0;x<canvas.width;x+=step){
    ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();
  }
  for(let y=0;y<canvas.height-step;y+=step){
    ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();
  }
  ctx.fillStyle='rgba(100,100,100,0.6)'; 
  ctx.fillRect(0,canvas.height-floorHeight,canvas.width,floorHeight);
}

// Part 2: Event handling and game loop
canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mousedown', e => {
  mouse.down = true;
  let nearest = null, ndist = Infinity;
  for(let bh of blackHoles){ const d = dist(e.clientX,e.clientY,bh.x,bh.y); if(d<50 && d<ndist){nearest=bh; ndist=d;} }
  for(let al of aliens){ const d = dist(e.clientX,e.clientY,al.x,al.y); if(d<30 && d<ndist){nearest=al; ndist=d;} }
  if(nearest){nearest.dragged = true; nearest.target = {x:e.clientX, y:e.clientY}; mouse.dragging = nearest;}
});
canvas.addEventListener('mouseup', e => { mouse.down = false; if(mouse.dragging){ mouse.dragging.dragged=false; mouse.dragging=null; } });

// UI buttons
document.getElementById('addBlackHole').addEventListener('click', () => {
  const mass = parseFloat(document.getElementById('bhMass').value);
  blackHoles.push(new BlackHole(canvas.width/2, canvas.height/2, mass));
});
document.getElementById('addAlien').addEventListener('click', () => {
  const mass = parseFloat(document.getElementById('alienMass').value);
  aliens.push(new Alien(Math.random()*canvas.width, Math.random()*canvas.height, mass));
});

// Main loop
function loop(){
  ctx.fillStyle = '#888'; ctx.fillRect(0,0,canvas.width,canvas.height);
  drawGrid();

  for(let bh of blackHoles){
    bh.mass = parseFloat(document.getElementById('bhMass').value);
    bh.update(); bh.draw();
  }

  for(let i=aliens.length-1; i>=0; i--){
    const al = aliens[i];
    al.update(blackHoles);
    if(al.spag !== undefined){ aliens.splice(i,1); continue; }
    al.draw();
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
