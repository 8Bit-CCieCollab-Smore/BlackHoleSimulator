<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Black Hole + Gravity (Canvas 2D, single file)</title>
<style>
  :root{
    --panel:#0d1022cc; --text:#eef2ff; --muted:#aab2d6;
  }
  html,body{margin:0;height:100%;background:#0b0c13;color:var(--text);font:14px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #wrap{position:fixed;inset:0}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  #ui{position:absolute;top:12px;left:12px;width:340px;max-height:88vh;overflow:auto;
      background:var(--panel);backdrop-filter:blur(6px);border:1px solid #1b2140;border-radius:16px;
      box-shadow:0 10px 30px #0008;padding:12px}
  #ui h1{font-size:16px;margin:0 0 8px}
  #ui .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
  #ui .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  button{background:#1a1f39;color:var(--text);border:1px solid #2a3260;border-radius:10px;padding:8px 10px;cursor:pointer}
  button:hover{border-color:#3b4890}
  label{color:var(--muted)}
  small{color:var(--muted)}
  #fps{color:var(--muted)}
  .nameTag{position:absolute;pointer-events:none;color:#eef2ff;text-shadow:0 0 6px #000,0 0 12px #000;font-weight:700}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="ui">
    <h1>üåÄ Black Hole + Orbits (2D)</h1>
    <div class="grid">
      <button id="addBH">+ Black Hole</button>
      <button id="addStar">+ Star</button>
      <button id="addPlanet">+ Planet</button>
      <button id="addSolar">‚òÄÔ∏è Solar System</button>
      <button id="clear">üßπ Clear</button>
      <button id="reset">‚ôªÔ∏è Reset View</button>
    </div>

    <div class="row"><label>Gravity G: <b id="gVal"></b></label><input id="g" type="range" min="0.15" max="2.0" step="0.001"></div>
    <div class="row"><label>Time Scale: <b id="tsVal"></b></label><input id="ts" type="range" min="0.2" max="2.5" step="0.01"></div>
    <div class="row"><label>Spaghettification Zone √óR<sub>s</sub>: <b id="zoneVal"></b></label><input id="zone" type="range" min="2" max="12" step="0.1"></div>
    <div class="row"><label>Max Stretch: <b id="stretchVal"></b></label><input id="stretch" type="range" min="1.0" max="5.0" step="0.05"></div>
    <div class="row"><label>Lensing Strength: <b id="lensVal"></b></label><input id="lens" type="range" min="0.6" max="2.2" step="0.02"></div>
    <div class="row"><label>Trails</label><input id="trails" type="checkbox"></div>
    <div class="row"><label>Labels</label><input id="labels" type="checkbox" checked></div>
    <div class="row"><label>Max Bodies: <b id="mbVal"></b></label><input id="maxb" type="range" min="10" max="300" step="10"></div>
    <div class="row"><small>Controls: Left-drag empty = pan ‚Ä¢ Wheel = zoom (cursor-centered) ‚Ä¢ Shift+drag a body to move it ‚Ä¢ Wheel on body = mass</small></div>
    <div class="row"><span id="fps">FPS</span></div>
  </div>
</div>

<script>
(() => {
  // ========= Canvas & DPI =========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=0, H=0;

  function resize(){
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    rebuildBackground();
  }
  window.addEventListener('resize', resize);

  // ========= Camera (no wrap; infinite space) =========
  const cam = {
    x: 0, y: 0, // world coords at screen center
    z: 1.0      // zoom (pixels per world unit)
  };
  const toScreen = (wx,wy)=>[(wx-cam.x)*cam.z + W/2, (wy-cam.y)*cam.z + H/2];
  const toWorld  = (sx,sy)=>[(sx - W/2)/cam.z + cam.x, (sy - H/2)/cam.z + cam.y];

  // Zoom (cursor-centered)
  canvas.addEventListener('wheel', e=>{
    const zoomFactor = Math.exp(-e.deltaY*0.0015);
    const [wx,wy] = toWorld(e.clientX, e.clientY);
    cam.z = Math.max(0.2, Math.min(4.0, cam.z*zoomFactor));
    // keep cursor position stable in world space
    const [wx2,wy2] = toWorld(e.clientX, e.clientY);
    cam.x += (wx - wx2);
    cam.y += (wy - wy2);
    e.preventDefault();
  }, {passive:false});

  // Pan
  let panning=false, panStart=[0,0], camStart=[0,0];
  canvas.addEventListener('pointerdown', e=>{
    if(e.buttons===1){ // left
      // if we're not shift-dragging a body (handled later), pan
      panning=true; panStart=[e.clientX,e.clientY]; camStart=[cam.x,cam.y];
      canvas.setPointerCapture(e.pointerId);
    }
  });
  canvas.addEventListener('pointermove', e=>{
    if(panning){
      const dx = (e.clientX - panStart[0]) / cam.z;
      const dy = (e.clientY - panStart[1]) / cam.z;
      cam.x = camStart[0] - dx;
      cam.y = camStart[1] - dy;
    }
  });
  canvas.addEventListener('pointerup', ()=>{ panning=false; });

  // ========= Procedural Background (detailed ‚Üí lensing visible) =========
  // We'll render the **world background** (nebula + stars + grid) to an offscreen canvas each frame,
  // using the camera to pick the portion of an infinite tiling.
  const bgTile = document.createElement('canvas'); // single tile
  const bgctx = bgTile.getContext('2d');
  const TILE = 1024; // tile size in world px (pre-zoom)
  bgTile.width = TILE; bgTile.height = TILE;

  function perlin2D(x,y,seed){
    const n = Math.sin(x*12.9898 + y*78.233 + seed)*43758.5453;
    return n - Math.floor(n);
  }
  function rebuildBackground(){
    // deep purple/blue gradient base per tile
    const g = bgctx.createRadialGradient(TILE*0.65,TILE*0.35, 40, TILE*0.5,TILE*0.5, Math.hypot(TILE,TILE)*0.9);
    g.addColorStop(0.00, '#3f3a6b');
    g.addColorStop(0.35, '#2b2f56');
    g.addColorStop(0.72, '#171a2a');
    g.addColorStop(1.00, '#0b0c13');
    bgctx.fillStyle=g; bgctx.fillRect(0,0,TILE,TILE);

    // faint nebula blotches
    const img = bgctx.getImageData(0,0,TILE,TILE);
    const d = img.data;
    for(let y=0;y<TILE;y++){
      for(let x=0;x<TILE;x++){
        const p = perlin2D(x*0.008, y*0.008, 12.3);
        const i = (y*TILE+x)*4;
        // add bluish/purple fog
        d[i  ] = Math.min(255, d[i  ] + p*20);
        d[i+1] = Math.min(255, d[i+1] + p*16);
        d[i+2] = Math.min(255, d[i+2] + p*28);
      }
    }
    bgctx.putImageData(img,0,0);

    // sprinkle varied stars
    bgctx.save();
    for(let i=0;i<400;i++){
      const x=(Math.random()*TILE)|0, y=(Math.random()*TILE)|0;
      const r=Math.random()*1.3;
      const a=0.18+Math.random()*0.6;
      bgctx.globalAlpha=a;
      bgctx.fillStyle= Math.random()<0.7 ? '#e8edff' : '#c7d2ff';
      bgctx.beginPath(); bgctx.arc(x,y,r,0,Math.PI*2); bgctx.fill();
    }
    bgctx.restore();
  }

  // draw tiled background for current camera view
  function drawBackground(){
    const sx = cam.x - W/(2*cam.z);
    const sy = cam.y - H/(2*cam.z);
    const ex = cam.x + W/(2*cam.z);
    const ey = cam.y + H/(2*cam.z);
    const x0 = Math.floor(sx / TILE) * TILE;
    const y0 = Math.floor(sy / TILE) * TILE;

    for(let y=y0; y<ey; y+=TILE){
      for(let x=x0; x<ex; x+=TILE){
        const [s0x,s0y] = toScreen(x,y);
        ctx.drawImage(bgTile, s0x, s0y, TILE*cam.z, TILE*cam.z);
      }
    }
  }

  // ========= World Grid (distorted by lensing later) =========
  function drawGrid(){
    // choose a nice spacing based on zoom
    const base = 100; // world units
    const scales = [0.25,0.5,1,2,4,8,16,32];
    let step = base;
    for(const s of scales){ if(base*s*cam.z>60){ step=base*s; break; } }
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(200,210,240,0.12)';
    // draw verticals
    const sx = cam.x - W/(2*cam.z), ex = cam.x + W/(2*cam.z);
    const sy = cam.y - H/(2*cam.z), ey = cam.y + H/(2*cam.z);
    const x0 = Math.floor(sx/step)*step, y0 = Math.floor(sy/step)*step;

    for(let x=x0; x<ex; x+=step){
      const a = Math.abs(Math.round(x))% (step*5)===0 ? 0.22 : 0.12;
      ctx.strokeStyle = `rgba(200,210,240,${a})`;
      const [sx0,sy0] = toScreen(x, sy), [sx1,sy1] = toScreen(x, ey);
      ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
    }
    for(let y=y0; y<ey; y+=step){
      const a = Math.abs(Math.round(y))% (step*5)===0 ? 0.22 : 0.12;
      ctx.strokeStyle = `rgba(200,210,240,${a})`;
      const [sx0,sy0] = toScreen(sx, y), [sx1,sy1] = toScreen(ex, y);
      ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
    }

    // origin crosshair
    ctx.strokeStyle='rgba(255,255,255,0.28)';
    ctx.lineWidth=1.2;
    const [ox0,oy0]=toScreen(0,sy), [ox1,oy1]=toScreen(0,ey);
    ctx.beginPath(); ctx.moveTo(ox0,oy0); ctx.lineTo(ox1,oy1); ctx.stroke();
    const [ox2,oy2]=toScreen(sx,0), [ox3,oy3]=toScreen(ex,0);
    ctx.beginPath(); ctx.moveTo(ox2,oy2); ctx.lineTo(ox3,oy3); ctx.stroke();
    ctx.restore();
  }

  // ========= Names / Colors =========
  const NAME = {
    systems: ["Solar","Alpha Centauri","TRAPPIST-1","Kepler-90","Kepler-11","HD 219134","TOI-700","Gliese 581","KIC 8462852","LHS 1140"],
    stars:   ["Sun","Sirius","Proxima","Betelgeuse","Rigel","Vega","Altair","Deneb","Arcturus","Polaris","Tau Ceti","Epsilon Eridani","Kepler-452"],
    planets: ["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Kepler-186f","Kepler-22b","Kepler-62f","Proxima b","TRAPPIST-1e","LHS 1140 b","Gliese 581g","HD 209458 b","WASP-12b","K2-18b"],
    blackholes: ["Sagittarius A*","M87*","Cygnus X-1","LMC X-3","NGC 1277*","GRO J1655-40","A0620-00","V404 Cygni","M60-UCD1*","TON 618"]
  };
  const TYPE = { BH:'bh', STAR:'star', PLANET:'planet' };
  const rand=(a=0,b=1)=>a+Math.random()*(b-a);
  const TAU=Math.PI*2;
  const clamp=(v,a,b)=>v<a?a:v>b?b:v;

  const planetPalette = ['#8fd3ff','#9ae6b4','#eab1ff','#ffd6a5','#c0b6ff','#a1f0ff','#ffadbc','#9cffd1','#d1ffe2','#c6f7ff'];
  const starPalette   = ['#ffd07a','#fff3c2','#ffe3a1','#d6e6ff','#ffdcdc'];

  function randomName(type){
    if(type===TYPE.BH) return NAME.blackholes[(Math.random()*NAME.blackholes.length)|0];
    if(type===TYPE.STAR) return NAME.stars[(Math.random()*NAME.stars.length)|0];
    return NAME.planets[(Math.random()*NAME.planets.length)|0];
  }
  function pickColor(type){
    if(type===TYPE.BH) return '#9be1ff';
    if(type===TYPE.STAR) return starPalette[(Math.random()*starPalette.length)|0];
    return planetPalette[(Math.random()*planetPalette.length)|0];
  }

  // ========= Physics =========
  const params = {
    G: 0.6,
    dtScale: 1.0,
    zoneMult: 6.0,     // spaghettification zone = zoneMult * BH radius
    maxStretch: 3.2,   // max elongation inside zone
    lensing: 1.1,      // how strong annulus magnifies
    drawTrails: false,
    drawLabels: true,
    maxBodies: 150
  };

  const bodies = [];
  const trails = [];
  const MAX_TRAIL = 80;

  // Accretion disks (per BH id)
  const disks = new Map(); // id -> {power,angle}

  function radiusFromMass(m, type){
    if(type===TYPE.BH)   return Math.max(4, Math.sqrt(m)/10);   // pseudo Rs
    if(type===TYPE.STAR) return Math.max(2, Math.pow(m,0.35));
    return Math.max(2, Math.pow(m,0.33));
  }

  function makeBody(type, opts={}){
    const b = {
      id: Math.random().toString(36).slice(2),
      type,
      x: opts.x ?? rand(-200,200),
      y: opts.y ?? rand(-200,200),
      vx: opts.vx ?? rand(-30,30),
      vy: opts.vy ?? rand(-30,30),
      m:  opts.m ?? (type===TYPE.BH ? rand(2e4, 8e4) : type===TYPE.STAR ? rand(3e3, 1.5e4) : rand(50,700)),
      r:  0,
      name: opts.name ?? randomName(type),
      color: opts.color ?? pickColor(type),
      acc: {x:0,y:0},
      locked:false,
      fading:false, fadeT:0
    };
    b.r = radiusFromMass(b.m, type);
    bodies.push(b); trails.push([]);
    if(type===TYPE.BH) disks.set(b.id, {power:0, angle:0});
    return b;
  }

  function gravityStep(dt){
    for(const b of bodies){ b.acc.x=0; b.acc.y=0; }

    const toMerge=[];
    for(let i=0;i<bodies.length;i++){
      const bi=bodies[i];
      for(let j=i+1;j<bodies.length;j++){
        const bj=bodies[j];
        const dx=bj.x-bi.x, dy=bj.y-bi.y;
        const d2=dx*dx+dy*dy + 25;
        const d=Math.sqrt(d2);
        const f = params.G*bi.m*bj.m/d2;
        const fx=f*dx/d, fy=f*dy/d;
        bi.acc.x += fx/bi.m; bi.acc.y += fy/bi.m;
        bj.acc.x -= fx/bj.m; bj.acc.y -= fy/bj.m;

        // Accretion when BH horizon reached
        if((bi.type===TYPE.BH || bj.type===TYPE.BH) && d < Math.max(bi.r,bj.r)*0.85){
          const eater = (bi.type===TYPE.BH) ? i : j;
          const food  = (bi.type===TYPE.BH) ? j : i;
          toMerge.push([eater,food]);
        }
      }
    }

    for(const b of bodies){
      b.vx += b.acc.x * dt; b.vy += b.acc.y * dt;
      if(!b.locked){ b.x += b.vx * dt; b.y += b.vy * dt; }
      // no wrap: free space
    }

    // Apply merges & trigger disks
    if(toMerge.length){
      for(const [ei,fi] of toMerge){
        const eater=bodies[ei], food=bodies[fi];
        if(!eater||!food||eater===food) continue;
        const totalM=eater.m+food.m;
        eater.vx=(eater.vx*eater.m + food.vx*food.m)/totalM;
        eater.vy=(eater.vy*eater.m + food.vy*food.m)/totalM;
        eater.m=totalM; eater.r=radiusFromMass(eater.m,eater.type);
        // disk boost
        if(eater.type===TYPE.BH){
          const dsk=disks.get(eater.id); if(dsk){ dsk.power = Math.min(1.0, dsk.power + Math.min(0.75, food.m/8000)); }
        }
        // fade food
        food.fading=true; food.fadeT=0;
      }
    }
  }

  // ========= Spaghettification zone =========
  function spaghettiDeform(body){
    // find nearest BH + distance
    let best=null, bestD=Infinity, dir=[1,0];
    for(const b of bodies){
      if(b.type!==TYPE.BH) continue;
      const dx=b.x-body.x, dy=b.y-body.y;
      const d=Math.hypot(dx,dy);
      if(d<bestD){ best=b; bestD=d; dir=[dx/d,dy/d]; }
    }
    if(!best) return {a:0, ex:1, ey:1};
    const zone = params.zoneMult * best.r;
    if(bestD >= zone) return {a:Math.atan2(dir[1],dir[0]), ex:1, ey:1}; // no stretch outside
    const t = 1 - (bestD - best.r) / (zone - best.r); // 0 at zone edge ‚Üí 1 near horizon
    const k = 1 + t*(params.maxStretch-1); // stretch factor 1..max
    const squash = 1/Math.sqrt(k);
    return {a:Math.atan2(dir[1],dir[0]), ex:k, ey:squash};
  }

  // ========= Rendering helpers =========
  const labelNodes = new Map();
  function drawLabel(b){
    if(!params.drawLabels) return;
    let n = labelNodes.get(b.id);
    if(!n){ n=document.createElement('div'); n.className='nameTag'; document.body.appendChild(n); labelNodes.set(b.id,n); }
    const [sx,sy]=toScreen(b.x,b.y);
    n.textContent = `${b.name} (${b.type})`;
    n.style.left = (sx + 8) + 'px';
    n.style.top  = (sy - b.r*cam.z - 14) + 'px';
    n.style.display='block';
  }
  function cleanupLabels(){
    const alive = new Set(bodies.map(b=>b.id));
    for(const [id,node] of labelNodes){
      if(!alive.has(id)){ node.remove(); labelNodes.delete(id); }
    }
    if(!params.drawLabels){ for(const node of labelNodes.values()) node.style.display='none'; }
  }

  function pushTrail(i){
    if(!params.drawTrails){ trails[i].length=0; return; }
    const t=trails[i], b=bodies[i];
    t.push([b.x,b.y]); if(t.length>MAX_TRAIL) t.shift();
    ctx.save(); ctx.globalAlpha=0.6; ctx.lineWidth=1.2; ctx.strokeStyle=b.color;
    ctx.beginPath();
    for(let k=0;k<t.length;k++){
      const p=t[k]; const [sx,sy]=toScreen(p[0],p[1]);
      if(k===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
    }
    ctx.stroke(); ctx.restore();
  }

  // Accretion disk draw
  function drawDisk(bh){
    const dsk = disks.get(bh.id); if(!dsk || dsk.power<=0.001) return;
    dsk.angle += 0.6 * (1 + 0.5*dsk.power); // rotate
    dsk.power = Math.max(0, dsk.power - 0.003); // fade

    const [sx,sy]=toScreen(bh.x,bh.y);
    const R1 = bh.r*cam.z*1.25, R2 = bh.r*cam.z*2.1;
    ctx.save();
    ctx.translate(sx,sy);
    ctx.rotate(dsk.angle*0.02);

    // bright ring with slight gap to mimic Doppler boosted side
    const grd = ctx.createRadialGradient(0,0,R1, 0,0,R2);
    grd.addColorStop(0, `rgba(255,240,210,${0.20+0.35*dsk.power})`);
    grd.addColorStop(0.4, `rgba(255,200,120,${0.25+0.45*dsk.power})`);
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=grd;
    ctx.beginPath(); ctx.arc(0,0,R2,0,TAU); ctx.arc(0,0,R1,0,TAU,true); ctx.fill();

    // boosted side
    ctx.globalAlpha = 0.35+0.45*dsk.power;
    ctx.beginPath(); ctx.ellipse(0,0,(R1+R2)/2,(R1+R2)*0.28/2,0, -0.35, 0.35); ctx.strokeStyle='#ffd9a3'; ctx.lineWidth=2; ctx.stroke();

    ctx.restore();
    ctx.globalCompositeOperation='source-over';
  }

  // Lensing: sample the composed background (bg+grid) by drawing scaled passes in an annulus
  function lensingPass(bh){
    const [sx,sy]=toScreen(bh.x,bh.y);
    const r = bh.r * cam.z;
    const inner = r*1.02;
    const outer = r*(1.9 + 0.25*params.lensing);

    // make a snapshot of current frame (bg + grid) to refract from
    const snapshot = ctx.getImageData(0,0,W,H);
    const snapCanvas = document.createElement('canvas');
    snapCanvas.width=W; snapCanvas.height=H;
    snapCanvas.getContext('2d').putImageData(snapshot,0,0);

    ctx.save();
    // annulus clip
    ctx.beginPath(); ctx.arc(sx,sy, outer, 0, TAU);
    ctx.arc(sx,sy, inner, 0, TAU, true);
    ctx.clip('evenodd');

    // multiple passes: outward magnification + slight swirl
    for(let i=0;i<4;i++){
      const s = 1 + params.lensing*(0.06 + i*0.06);
      const angle = (i-1.5)*0.04;
      const w = W*s, h=H*s;
      ctx.globalAlpha = 0.45 - i*0.1;
      ctx.translate(sx,sy); ctx.rotate(angle); ctx.translate(-sx,-sy);
      ctx.drawImage(snapCanvas, (W-w)/2, (H-h)/2, w,h);
      ctx.setTransform(DPR,0,0,DPR,0,0); // reset matrix to screen coords
    }
    ctx.restore();

    // horizon & photon ring
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(sx,sy, r, 0, TAU); ctx.fill();
    ctx.strokeStyle = '#a8dfff'; ctx.globalAlpha=0.65; ctx.lineWidth=1.3;
    ctx.beginPath(); ctx.arc(sx,sy, r*1.03, 0, TAU); ctx.stroke();
    ctx.globalAlpha=1;
  }

  // ========= Draw bodies (with deformation only inside zone) =========
  function drawBodies(dt){
    const toRemove = [];
    for(let i=0;i<bodies.length;i++){
      const b=bodies[i];
      pushTrail(i);

      if(b.type===TYPE.BH){
        // disks and labels later (after lensing so disk overlays)
        drawLabel(b);
        continue;
      }

      // deformation inside zone of nearest BH
      const def = spaghettiDeform(b);
      const [sx,sy]=toScreen(b.x,b.y);

      ctx.save();
      ctx.translate(sx,sy);
      ctx.rotate(def.a);
      ctx.scale(def.ex, def.ey);

      // fade on accretion
      let alpha=1;
      if(b.fading){
        b.fadeT += dt*1.6;
        alpha = clamp(1 - b.fadeT, 0, 1);
        if(alpha<=0){ toRemove.push(i); ctx.restore(); continue; }
      }
      ctx.globalAlpha=alpha;

      if(b.type===TYPE.STAR){
        const R=b.r*cam.z;
        const grd = ctx.createRadialGradient(0,0,R*0.35, 0,0,R*1.8);
        grd.addColorStop(0,'#fff6d6');
        grd.addColorStop(0.25,b.color);
        grd.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(0,0,R*1.8,0,TAU); ctx.fill();
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,R*0.8,0,TAU); ctx.fill();
      } else {
        const R=b.r*cam.z;
        ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(0,0,R,0,TAU); ctx.fill();
        ctx.globalAlpha=alpha*0.6; ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(-R*0.3,-R*0.3, R*0.3, 0, TAU); ctx.fill();
      }
      ctx.restore();
      drawLabel(b);
    }

    // remove fully faded
    if(toRemove.length){
      toRemove.sort((a,b)=>b-a);
      for(const idx of toRemove){
        const dead=bodies[idx];
        bodies.splice(idx,1); trails.splice(idx,1);
        const node=labelNodes.get(dead.id); if(node){ node.remove(); labelNodes.delete(dead.id); }
      }
    }
  }

  // ========= Interaction: body drag + mass scroll =========
  let draggingBody=null;
  canvas.addEventListener('pointerdown', e=>{
    if(e.shiftKey){
      // pick nearest body under cursor
      const [wx,wy]=toWorld(e.clientX,e.clientY);
      let best=null, bd=1e9;
      for(const b of bodies){
        const d2=(b.x-wx)**2+(b.y-wy)**2;
        if(d2<bd && Math.sqrt(d2)<Math.max(20,b.r+18)){ bd=d2; best=b; }
      }
      if(best){ draggingBody=best; best.locked=true; best.vx=0; best.vy=0; canvas.setPointerCapture(e.pointerId); }
    }
  });
  canvas.addEventListener('pointermove', e=>{
    if(draggingBody){
      const [wx,wy]=toWorld(e.clientX,e.clientY);
      draggingBody.x=wx; draggingBody.y=wy;
    }
  });
  canvas.addEventListener('pointerup', ()=>{ if(draggingBody){ draggingBody.locked=false; draggingBody=null; } });

  canvas.addEventListener('wheel', e=>{
    // adjust mass for nearest body under cursor
    const [wx,wy]=toWorld(e.clientX,e.clientY);
    let best=null, bd=1e9;
    for(const b of bodies){
      const d2=(b.x-wx)**2+(b.y-wy)**2; if(d2<bd){ bd=d2; best=b; }
    }
    if(best){
      best.m = clamp(best.m * (e.deltaY<0 ? 1.08 : 0.925), 10, 1e7);
      best.r = radiusFromMass(best.m, best.type);
    }
  }, {passive:false});

  // ========= UI =========
  function $(id){return document.getElementById(id)}
  const syncVals=()=>{
    $('gVal').textContent=params.G.toFixed(3);
    $('tsVal').textContent=params.dtScale.toFixed(2);
    $('zoneVal').textContent=params.zoneMult.toFixed(1);
    $('stretchVal').textContent=params.maxStretch.toFixed(2);
    $('lensVal').textContent=params.lensing.toFixed(2);
    $('mbVal').textContent=params.maxBodies;
  };
  $('g').value=params.G; $('ts').value=params.dtScale; $('zone').value=params.zoneMult; $('stretch').value=params.maxStretch; $('lens').value=params.lensing; $('trails').checked=params.drawTrails; $('labels').checked=params.drawLabels; $('maxb').value=params.maxBodies; syncVals();

  $('g').oninput=e=>{ params.G=parseFloat(e.target.value); syncVals(); };
  $('ts').oninput=e=>{ params.dtScale=parseFloat(e.target.value); syncVals(); };
  $('zone').oninput=e=>{ params.zoneMult=parseFloat(e.target.value); syncVals(); };
  $('stretch').oninput=e=>{ params.maxStretch=parseFloat(e.target.value); syncVals(); };
  $('lens').oninput=e=>{ params.lensing=parseFloat(e.target.value); syncVals(); };
  $('trails').onchange=e=>{ params.drawTrails=e.target.checked; };
  $('labels').onchange=e=>{ params.drawLabels=e.target.checked; if(!params.drawLabels){ for(const node of labelNodes.values()) node.style.display='none'; } };
  $('maxb').oninput=e=>{ params.maxBodies=parseInt(e.target.value,10); syncVals(); };
  $('clear').onclick=()=>{ bodies.length=0; trails.length=0; for(const n of labelNodes.values()) n.remove(); labelNodes.clear(); disks.clear(); };
  $('reset').onclick=()=>{ cam.x=0; cam.y=0; cam.z=1; };

  $('addBH').onclick=()=>{ if(bodies.length>=params.maxBodies) return; makeBody(TYPE.BH,{x:cam.x+rand(-200,200)/cam.z, y:cam.y+rand(-200,200)/cam.z, m:rand(3e4,9e4), vx:0,vy:0}); };
  $('addStar').onclick=()=>{ if(bodies.length>=params.maxBodies) return; makeBody(TYPE.STAR,{x:cam.x+rand(-300,300)/cam.z, y:cam.y+rand(-300,300)/cam.z, m:rand(5e3,1.2e4)}); };
  $('addPlanet').onclick=()=>{ if(bodies.length>=params.maxBodies) return; makeBody(TYPE.PLANET,{x:cam.x+rand(-300,300)/cam.z, y:cam.y+rand(-300,300)/cam.z, m:rand(80,1200)}); };
  $('addSolar').onclick=()=> {
    const cx = cam.x, cy = cam.y;
    const star = makeBody(TYPE.STAR,{x:cx,y:cy,m:rand(9e3,1.5e4),vx:0,vy:0,name:NAME.systems[(Math.random()*NAME.systems.length)|0]+' ‚òÄ'});
    const Np=7;
    for(let i=0;i<Np;i++){
      const a=rand(0,TAU), R=120+i*70+rand(-10,10);
      const vmag=Math.sqrt(params.G*star.m/Math.max(R,10));
      const x=cx+Math.cos(a)*R, y=cy+Math.sin(a)*R;
      const vx=-Math.sin(a)*vmag, vy=Math.cos(a)*vmag;
      makeBody(TYPE.PLANET,{x,y,m:rand(90,1200),vx,vy,color:pickColor(TYPE.PLANET), name:randomName(TYPE.PLANET)});
    }
  };

  // ========= Main Loop =========
  let last=performance.now(), fpsAcc=0,fpsCount=0;
  function step(now){
    const dt = ((now-last)/1000) * params.dtScale; last=now;

    gravityStep(dt);

    // 1) Background + grid (world space)
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawGrid();

    // 2) Lensing pass for each BH over background/grid
    for(const b of bodies){ if(b.type===TYPE.BH) lensingPass(b); }

    // 3) Bodies (planets/stars) + labels
    drawBodies(dt);

    // 4) Accretion disks drawn on top of horizon
    for(const b of bodies){ if(b.type===TYPE.BH) drawDisk(b); }

    cleanupLabels();

    // FPS
    fpsAcc+=dt; fpsCount++;
    if(fpsAcc>=0.5){
      const fps=(fpsCount/fpsAcc)|0;
      document.getElementById('fps').textContent=`FPS: ${fps} ‚Ä¢ Bodies: ${bodies.length} ‚Ä¢ Zoom: ${cam.z.toFixed(2)}x`;
      fpsAcc=0; fpsCount=0;
    }

    requestAnimationFrame(step);
  }

  // ========= Bootstrap =========
  resize();                 // scene starts empty
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
