<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Black Hole Simulator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #444;
      color: white;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 8px;
    }
    #ui button, #ui select, #ui input {
      margin: 4px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="sim"></canvas>
  <div id="ui">
    <select id="objectType">
      <option value="blackhole">Black Hole</option>
      <option value="star">Star</option>
      <option value="planet">Planet</option>
    </select>
    <button id="addObject">Add</button>
    <button id="clear">Clear</button>
    <label>
      Speed:
      <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </label>
  </div>
  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    let objects = [];
    let simulationSpeed = 1;

    class Body {
      constructor(x, y, mass, type) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.mass = mass;
        this.type = type;
        this.radius = Math.cbrt(mass) * 2;
      }
      draw() {
        if (this.type === "blackhole") {
          ctx.beginPath();
          ctx.fillStyle = "black";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
          // gravitational lensing grid distortion
          drawDistortion(this.x, this.y, this.radius * 4);
        } else if (this.type === "star") {
          ctx.beginPath();
          ctx.fillStyle = "yellow";
          ctx.shadowBlur = 20;
          ctx.shadowColor = "yellow";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          ctx.beginPath();
          ctx.fillStyle = "lightblue";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function drawGrid() {
      ctx.strokeStyle = "rgba(200,200,200,0.2)";
      ctx.lineWidth = 1;
      let step = 50;
      for (let x = 0; x < canvas.width; x += step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawDistortion(cx, cy, radius) {
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    function updatePhysics() {
      const G = 0.1;
      for (let i = 0; i < objects.length; i++) {
        let a = objects[i];
        for (let j = i + 1; j < objects.length; j++) {
          let b = objects[j];
          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let distSq = dx * dx + dy * dy;
          let dist = Math.sqrt(distSq);
          if (dist < a.radius + b.radius) continue; // skip collision
          let force = (G * a.mass * b.mass) / distSq;
          let ax = (force / a.mass) * (dx / dist);
          let ay = (force / a.mass) * (dy / dist);
          let bx = (force / b.mass) * (-dx / dist);
          let by = (force / b.mass) * (-dy / dist);
          a.vx += ax * simulationSpeed;
          a.vy += ay * simulationSpeed;
          b.vx += bx * simulationSpeed;
          b.vy += by * simulationSpeed;
        }
      }
      for (let obj of objects) {
        obj.x += obj.vx * simulationSpeed;
        obj.y += obj.vy * simulationSpeed;
      }
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      updatePhysics();
      for (let obj of objects) obj.draw();
      requestAnimationFrame(loop);
    }
    loop();

    // UI Handlers
    document.getElementById("addObject").onclick = () => {
      let type = document.getElementById("objectType").value;
      if (type === "blackhole")
        objects.push(new Body(canvas.width / 2, canvas.height / 2, 1000, "blackhole"));
      else if (type === "star")
        objects.push(new Body(Math.random() * canvas.width, Math.random() * canvas.height, 200, "star"));
      else
        objects.push(new Body(Math.random() * canvas.width, Math.random() * canvas.height, 50, "planet"));
    };
    document.getElementById("clear").onclick = () => (objects = []);
    document.getElementById("speed").oninput = (e) => (simulationSpeed = parseFloat(e.target.value));
  </script>
</body>
</html>
