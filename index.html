<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Black Hole Sandbox (Canvas)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background:#000; overflow: hidden; font-family: system-ui, Arial, sans-serif; }
    #overlay {
      position: absolute; top: 12px; left: 12px; width: 260px;
      background: rgba(255,255,255,0.9); color:#111; padding:12px 14px;
      border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,0.35); font-size:14px; z-index:10;
    }
    #overlay h3 { margin:0 0 8px 0; font-size:16px; }
    #overlay .row { display:flex; gap:8px; margin:6px 0; }
    #overlay button {
      flex:1; background:#111; color:#fff; border:0; border-radius:8px; padding:8px 10px; cursor:pointer;
    }
    #overlay button:hover { background:#333; }
    #overlay label { display:block; margin:6px 0; }
    #overlay input[type="range"] { width:100%; }
    #hint {
      position:absolute; right:12px; top:12px; color:#bbb; font-size:12px;
      background: rgba(255,255,255,0.1); padding:8px 10px; border-radius:10px; pointer-events:none;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="overlay">
    <h3>üåå Black Hole Sandbox</h3>
    <div class="row">
      <button id="addPlanetBtn">‚ûï Planet</button>
      <button id="addBHBtn">üï≥Ô∏è Black Hole</button>
    </div>
    <label>BH Mass <input id="massSlider" type="range" min="2000" max="30000" step="500" value="9000"></label>
    <label>BH Radius <input id="radiusSlider" type="range" min="20" max="120" step="5" value="60"></label>
    <label>Supernova on Merge
      <input id="supernovaChk" type="checkbox" checked>
    </label>
    <small>
      ‚Ä¢ Drag to pan ‚Ä¢ Wheel to zoom<br>
      ‚Ä¢ Planets spaghettify near BH, fade on horizon<br>
      ‚Ä¢ BHs attract, orbit, and merge (clockwise glowing disks)
    </small>
  </div>
  <div id="hint">drag = pan ‚Ä¢ wheel = zoom ‚Ä¢ double-click = center</div>

  <canvas id="c"></canvas>

  <script>
  // ===== Helpers =====
  const randIndex = n => (Math.random()*n) | 0;
  const pick = arr => arr[randIndex(arr.length)];

  // ===== Canvas & Camera =====
  const cv = document.getElementById('c');
  const ctx = cv.getContext('2d');
  const DPR = Math.min(2, window.devicePixelRatio || 1);

  const cam = { x: 0, y: 0, s: 1.0, minS: 0.3, maxS: 3.0 };

  function resize() {
    cv.width = Math.floor(window.innerWidth * DPR);
    cv.height = Math.floor(window.innerHeight * DPR);
    cv.style.width = window.innerWidth + 'px';
    cv.style.height = window.innerHeight + 'px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(DPR, DPR);
  }
  window.addEventListener('resize', resize);
  resize();

  function worldToScreen(wx, wy) {
    const sx = (wx - cam.x) * cam.s + window.innerWidth/2;
    const sy = (wy - cam.y) * cam.s + window.innerHeight/2;
    return {x:sx, y:sy};
  }
  function screenToWorld(sx, sy) {
    const wx = (sx - window.innerWidth/2)/cam.s + cam.x;
    const wy = (sy - window.innerHeight/2)/cam.s + cam.y;
    return {x:wx, y:wy};
  }

  // ===== Input (pan/zoom) =====
  let dragging = false;
  let lastMouse = {x:0,y:0};

  cv.addEventListener('mousedown', e=>{
    dragging = true; lastMouse.x = e.clientX; lastMouse.y = e.clientY;
  });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    const dx = (e.clientX - lastMouse.x) / cam.s;
    const dy = (e.clientY - lastMouse.y) / cam.s;
    cam.x -= dx;
    cam.y -= dy;
    lastMouse.x = e.clientX; lastMouse.y = e.clientY;
  });
  cv.addEventListener('wheel', e=>{
    e.preventDefault();
    const mouseWorld = screenToWorld(e.clientX, e.clientY);
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const newS = Math.max(cam.minS, Math.min(cam.maxS, cam.s * zoomFactor));
    const scale = newS / cam.s;
    // zoom to cursor
    cam.x = mouseWorld.x - (mouseWorld.x - cam.x) * scale;
    cam.y = mouseWorld.y - (mouseWorld.y - cam.y) * scale;
    cam.s = newS;
  }, {passive:false});
  cv.addEventListener('dblclick', e=>{
    const w = screenToWorld(e.clientX, e.clientY);
    cam.x = w.x; cam.y = w.y;
  });

  // ===== World State =====
  const stars = [];
  const STAR_COUNT = 2000;
  const STAR_COLS = ['#fff','#ffd27f','#87cefa','#ffaaa5'];

  for (let i=0;i<STAR_COUNT;i++){
    stars.push({
      x: (Math.random()-0.5)*8000,
      y: (Math.random()-0.5)*8000,
      c: pick(STAR_COLS),
      s: Math.random()*1.5+0.5
    });
  }

  const planets = []; // {x,y,vx,vy,r,color,trail[],alive}
  const frags   = []; // {x,y,vx,vy,r,color,trail[],fade}
  const blackHoles = []; // {x,y,vx,vy,mass,radius,diskColors[],diskRot,waveT,mergeFlash}

  const settings = { defaultBHMass: 9000, defaultBHRadius: 60, supernova: true };

  // Initial BH at origin
  addBlackHoleAt(0,0);

  // ===== UI =====
  document.getElementById('massSlider').addEventListener('input', e=>{
    settings.defaultBHMass = +e.target.value;
  });
  document.getElementById('radiusSlider').addEventListener('input', e=>{
    settings.defaultBHRadius = +e.target.value;
  });
  document.getElementById('supernovaChk').addEventListener('change', e=>{
    settings.supernova = e.target.checked;
  });
  document.getElementById('addPlanetBtn').addEventListener('click', addPlanet);
  document.getElementById('addBHBtn').addEventListener('click', ()=>{
    const center = screenToWorld(window.innerWidth/2, window.innerHeight/2);
    addBlackHoleAt(center.x + (Math.random()-0.5)*200/cam.s, center.y + (Math.random()-0.5)*200/cam.s);
  });

  // ===== Entity Spawners =====
  const PLANET_COLS = ['#4cc9f0','#ff006e','#8338ec','#06d6a0','#ffd166'];

  function addPlanet() {
    const bh = blackHoles.length ? blackHoles[(Math.random()*blackHoles.length)|0] : {x:cam.x,y:cam.y};
    const dist = Math.random()*350 + 120;
    const ang = Math.random()*Math.PI*2;
    const x = bh.x + dist*Math.cos(ang);
    const y = bh.y + dist*Math.sin(ang);

    const Gspeed = Math.sqrt((totalBHMassNear(x,y))/dist) * (0.7 + Math.random()*0.6);
    const vx = -Math.sin(ang)*Gspeed;
    const vy =  Math.cos(ang)*Gspeed;

    planets.push({
      x, y, vx, vy,
      r: Math.random()*6 + 8,
      color: pick(PLANET_COLS),
      trail: [],
      alive: true
    });
  }

  function addBlackHoleAt(x,y) {
    blackHoles.push({
      x, y, vx:0, vy:0,
      mass: settings.defaultBHMass,
      radius: settings.defaultBHRadius,
      diskColors: [], // newest first (inner ring)
      diskRot: 0,
      waveT: 0,
      mergeFlash: 0
    });
  }

  function totalBHMassNear(x,y){
    let m = 0;
    for (const bh of blackHoles){
      const dx = bh.x - x, dy = bh.y - y;
      const d = Math.hypot(dx,dy) + 1;
      m += bh.mass / Math.max(1, d/200);
    }
    return m;
  }

  // ===== Physics =====
  function update(dt){
    // Planets
    for (let i=planets.length-1; i>=0; i--){
      const p = planets[i];
      let ax=0, ay=0;
      let nearestBH = null; let nearestD = Infinity;

      for (const b of blackHoles){
        const dx = b.x - p.x, dy = b.y - p.y;
        const r2 = dx*dx + dy*dy + 0.001;
        const d = Math.sqrt(r2);
        if (d < nearestD){ nearestD = d; nearestBH = b; }

        const F = b.mass / r2;
        ax += F * dx / d;
        ay += F * dy / d;
      }

      p.vx += ax*dt; p.vy += ay*dt;
      p.x  += p.vx*dt; p.y  += p.vy*dt;

      if (nearestBH && nearestD < nearestBH.radius*2 && p.alive){
        planets.splice(i,1);
        const pieces = 10;
        for (let k=0;k<pieces;k++){
          const jitter = 0.6 + Math.random()*0.8;
          frags.push({
            x:p.x, y:p.y,
            vx:p.vx*jitter, vy:p.vy*jitter,
            r:Math.max(2, p.r/3),
            color:p.color,
            trail:[],
            fade:1
          });
        }
        continue;
      }

      let consumed = false;
      for (const b of blackHoles){
        if (Math.hypot(b.x-p.x, b.y-p.y) <= b.radius){
          b.diskColors.unshift(p.color);
          if (b.diskColors.length > 8) b.diskColors = b.diskColors.slice(0,8);
          planets.splice(i,1);
          consumed = true;
          break;
        }
      }
      if (consumed) continue;

      p.trail.push({x:p.x, y:p.y});
      if (p.trail.length > 32) p.trail.shift();
    }

    // Fragments
    for (let i=frags.length-1; i>=0; i--){
      const f = frags[i];
      let ax=0, ay=0;
      let hitBH = null;
      for (const b of blackHoles){
        const dx = b.x - f.x, dy = b.y - f.y;
        const r2 = dx*dx + dy*dy + 0.001;
        const d = Math.sqrt(r2);
        const F = b.mass / r2;
        ax += F * dx / d;
        ay += F * dy / d;
        if (d <= b.radius) hitBH = b;
      }
      f.vx += ax*dt; f.vy += ay*dt;
      f.x  += f.vx*dt; f.y  += f.vy*dt;

      if (hitBH){
        hitBH.diskColors.unshift(f.color);
        if (hitBH.diskColors.length > 8) hitBH.diskColors = hitBH.diskColors.slice(0,8);
        frags.splice(i,1);
        continue;
      }

      f.trail.push({x:f.x, y:f.y});
      if (f.trail.length > 18) f.trail.shift();
      if (f.fade > 0.2) f.fade -= 0.001*dt;
    }

    // BH‚ÄìBH gravity & merge
    for (let i=0;i<blackHoles.length;i++){
      const A = blackHoles[i];
      for (let j=i+1;j<blackHoles.length;j++){
        const B = blackHoles[j];
        const dx = B.x - A.x, dy = B.y - A.y;
        const d2 = dx*dx + dy*dy + 0.001;
        const d  = Math.sqrt(d2);
        const F  = (A.mass * B.mass) / d2;
        const ax =  F * dx / d / A.mass;
        const ay =  F * dy / d / A.mass;
        const bx = -F * dx / d / B.mass;
        const by = -F * dy / d / B.mass;

        A.vx += ax*dt; A.vy += ay*dt;
        B.vx += bx*dt; B.vy += by*dt;

        if (d <= (A.radius + B.radius)*0.9){
          const big = (A.mass >= B.mass) ? A : B;
          const small = (A.mass < B.mass) ? A : B;

          big.vx = (big.vx*big.mass + small.vx*small.mass)/(big.mass+small.mass);
          big.vy = (big.vy*big.mass + small.vy*small.mass)/(big.mass+small.mass);
          big.mass += small.mass;
          big.radius = Math.min(140, Math.sqrt(big.radius*big.radius + small.radius*small.radius));
          big.diskColors = small.diskColors.concat(big.diskColors).slice(0,8);
          if (settings.supernova) big.mergeFlash = 1.0;

          const idx = blackHoles.indexOf(small);
          blackHoles.splice(idx,1);
          i = 0; break;
        }
      }
    }

    for (const b of blackHoles){
      b.x += b.vx*dt; b.y += b.vy*dt;
      b.vx *= 0.999; b.vy *= 0.999;
      if (b.mergeFlash > 0) b.mergeFlash = Math.max(0, b.mergeFlash - 0.02);
    }
  }

  // ===== Rendering =====
  function draw(){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

    // Stars
    for (const s of stars){
      const p = worldToScreen(s.x, s.y);
      if (p.x<-10||p.x>window.innerWidth+10||p.y<-10||p.y>window.innerHeight+10) continue;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = s.c;
      ctx.fillRect(p.x, p.y, s.s*cam.s, s.s*cam.s);
    }
    ctx.globalAlpha = 1;

    // Trails
    const strokeTrail = (trail, color, alpha=0.5)=>{
      if (trail.length<2) return;
      ctx.strokeStyle = color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      for (let i=0;i<trail.length;i++){
        const p = worldToScreen(trail[i].x, trail[i].y);
        if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke(); ctx.globalAlpha = 1;
    };
    for (const p of planets) strokeTrail(p.trail, p.color, 0.5);
    for (const f of frags)   strokeTrail(f.trail, f.color, 0.35);

    // Disks
    for (const b of blackHoles) drawAccretionDisk(b);

    // BH cores + supernova
    for (const b of blackHoles){
      const c = worldToScreen(b.x, b.y);
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(c.x, c.y, b.radius*cam.s, 0, Math.PI*2);
      ctx.fillStyle = '#000';
      ctx.fill();

      if (b.mergeFlash>0){
        const r = (b.radius*8 + Math.random()*30)*cam.s*b.mergeFlash;
        const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r);
        g.addColorStop(0, `rgba(255,255,255,${0.6*b.mergeFlash})`);
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
    }

    // Planets & fragments
    for (const p of planets){
      const s = worldToScreen(p.x, p.y);
      ctx.beginPath();
      ctx.arc(s.x, s.y, Math.max(1.5, p.r*cam.s), 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.fill();
    }
    for (const f of frags){
      const s = worldToScreen(f.x, f.y);
      ctx.globalAlpha = Math.max(0, Math.min(1, f.fade));
      ctx.beginPath();
      ctx.arc(s.x, s.y, Math.max(1, f.r*cam.s), 0, Math.PI*2);
      ctx.fillStyle = f.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawAccretionDisk(b){
    if (!b.diskColors.length) return;
    const center = worldToScreen(b.x, b.y);

    // clockwise
    b.diskRot -= 0.01;
    b.waveT += 0.05;

    const maxRings = Math.min(8, b.diskColors.length);
    const thick = 14 * cam.s;

    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.rotate(b.diskRot);
    ctx.globalCompositeOperation = 'lighter';

    for (let i=0;i<maxRings;i++){
      const color = b.diskColors[i];
      const inner = (b.radius*cam.s) + i*thick;
      const outer = inner + thick;

      // Outer halo pass
      ctx.beginPath();
      ringPath(inner, outer, b.waveT, i, 60, 3.5);
      ctx.shadowBlur = 50;           // brighter glow
      ctx.shadowColor = color;
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.28 * (1 - i/maxRings) * (0.9 + 0.1*Math.sin(b.waveT + i));
      ctx.fill();

      // Inner bright pass
      ctx.beginPath();
      ringPath(inner, outer, b.waveT, i, 60, 2.0);
      ctx.shadowBlur = 30;
      ctx.shadowColor = color;
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.42 * (1 - i/maxRings) * (0.9 + 0.1*Math.cos(b.waveT*1.2 + i));
      ctx.fill();

      ctx.globalAlpha = 1;
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
    ctx.shadowBlur = 0;
  }

  function ringPath(inner, outer, t, idx, steps=60, amp=3){
    for (let a=0;a<=steps;a++){
      const ang = (a/steps)*Math.PI*2;
      const wob = Math.sin(ang*4 + t + idx)*amp;
      const r = outer + wob;
      const x = Math.cos(ang)*r, y = Math.sin(ang)*r;
      if (a===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for (let a=steps;a>=0;a--){
      const ang = (a/steps)*Math.PI*2;
      const wob = Math.sin(ang*4 + t + idx)*amp;
      const r = inner + wob;
      const x = Math.cos(ang)*r, y = Math.sin(ang)*r;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
  }

  // ===== Main Loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.05, (now - last)/50);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  </script>
</body>
</html>
