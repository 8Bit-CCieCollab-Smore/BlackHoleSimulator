<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Black Hole Orbiter</title>
<style>
  html,body{margin:0;height:100%;background:black;overflow:hidden;color:white;font-family:sans-serif}
  #ui{position:fixed;top:10px;left:10px;font-size:14px;opacity:0.8}
  canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">Thrust: WASD â€¢ Time Warp: Space</div>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}
resize(); addEventListener("resize",resize);

// --- Player (probe) ---
const player={x:0,y:-400,vx:150,vy:0,trails:[]};

// --- Black Hole Parameters ---
const BH={x:0,y:0,radius:90,gravity:120000};

// --- Time warp memory ---
const rewindStack=[];
let warp=false;

// --- Generate background stars ---
const stars=[];
for(let i=0;i<400;i++){
  stars.push({
    x:(Math.random()-0.5)*5000,
    y:(Math.random()-0.5)*5000,
    r:Math.random()*1.5+0.5
  });
}

// --- Input ---
const keys=new Set();
onkeydown=e=>{keys.add(e.key.toLowerCase()); if(e.key===" ") warp=true;}
onkeyup=e=>{keys.delete(e.key.toLowerCase()); if(e.key===" ") warp=false;}

// --- Physics step ---
function step(dt){
  // Save state for rewind
  rewindStack.push(JSON.parse(JSON.stringify(player)));
  if(rewindStack.length>240) rewindStack.shift();

  if(warp && rewindStack.length>10){
    const past=rewindStack.splice(rewindStack.length-10,1)[0];
    Object.assign(player,past);
    return;
  }

  // Controls
  const thrust=200;
  if(keys.has("w")) player.vy-=thrust*dt;
  if(keys.has("s")) player.vy+=thrust*dt;
  if(keys.has("a")) player.vx-=thrust*dt;
  if(keys.has("d")) player.vx+=thrust*dt;

  // Gravity from black hole
  const dx=BH.x-player.x, dy=BH.y-player.y;
  const dist=Math.hypot(dx,dy);
  const force=BH.gravity/(dist*dist);
  player.vx+=force*dx/dist*dt;
  player.vy+=force*dy/dist*dt;

  // Position update
  player.x+=player.vx*dt;
  player.y+=player.vy*dt;

  // Add trail
  player.trails.push({x:player.x,y:player.y,life:1});
  if(player.trails.length>200) player.trails.shift();

  // Death check
  if(dist<BH.radius*0.9){
    player.x=0;player.y=-400;player.vx=150;player.vy=0;
    player.trails=[];
  }
}

// --- Render ---
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Stars (background distorted by BH lensing approx)
  ctx.fillStyle="white";
  for(const s of stars){
    let sx=canvas.width/2+s.x/10;
    let sy=canvas.height/2+s.y/10;
    // crude lensing: mirror stars near BH
    const dx=sx-canvas.width/2, dy=sy-canvas.height/2;
    const d=Math.hypot(dx,dy);
    if(d<200){
      sx=canvas.width/2+dx*200/d;
      sy=canvas.height/2+dy*200/d;
    }
    ctx.fillRect(sx,sy,s.r,s.r);
  }

  // Accretion disk
  const g=ctx.createRadialGradient(canvas.width/2,canvas.height/2, BH.radius*0.9,
                                   canvas.width/2,canvas.height/2, BH.radius*4);
  g.addColorStop(0,"rgba(255,180,60,0.8)");
  g.addColorStop(0.4,"rgba(255,100,0,0.7)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle=g;
  ctx.beginPath();
  ctx.ellipse(canvas.width/2,canvas.height/2, BH.radius*4, BH.radius*1.5,0,0,Math.PI*2);
  ctx.fill();

  // Black hole core
  ctx.beginPath();
  ctx.arc(canvas.width/2,canvas.height/2,BH.radius,0,Math.PI*2);
  ctx.fillStyle="black";
  ctx.fill();

  // Event horizon glow
  ctx.beginPath();
  ctx.arc(canvas.width/2,canvas.height/2,BH.radius+3,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,0.3)";
  ctx.lineWidth=6;
  ctx.stroke();

  // Trails
  for(const t of player.trails){
    const px=canvas.width/2+player.x/2+t.x/500;
    const py=canvas.height/2+player.y/2+t.y/500;
    ctx.fillStyle=`rgba(150,220,255,${t.life})`;
    ctx.beginPath();ctx.arc(px,py,2,0,Math.PI*2);ctx.fill();
    t.life-=0.02;
  }

  // Player probe
  const px=canvas.width/2+player.x/2;
  const py=canvas.height/2+player.y/2;
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.arc(px,py,6,0,Math.PI*2);
  ctx.fill();
}

// --- Loop ---
let last=performance.now();
function loop(now){
  const dt=Math.min(0.03,(now-last)/1000);
  last=now;
  step(dt);
  draw();
  requestAnimationFrame(loop);
}
loop(last);
</script>
</body>
</html>
