<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Black Hole Simulator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
      color: white;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px;
      border-radius: 8px;
    }
    #ui button, #ui select, #ui input {
      margin: 4px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="sim"></canvas>
  <div id="ui">
    <select id="objectType">
      <option value="blackhole">Black Hole</option>
      <option value="star">Star</option>
      <option value="planet">Planet</option>
    </select>
    <button id="addObject">Add</button>
    <button id="clear">Clear</button>
    <label>
      Speed:
      <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
    </label>
  </div>
  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    let objects = [];
    let particles = [];
    let simulationSpeed = 1;

    class Body {
      constructor(x, y, mass, type) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.mass = mass;
        this.type = type;
        this.radius = Math.cbrt(mass) * 2;
        this.destroyed = false;
      }
      draw() {
        if (this.type === "blackhole") {
          ctx.beginPath();
          ctx.fillStyle = "black";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        } else if (this.type === "star") {
          ctx.beginPath();
          ctx.fillStyle = "yellow";
          ctx.shadowBlur = 20;
          ctx.shadowColor = "yellow";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          ctx.beginPath();
          ctx.fillStyle = "lightblue";
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }

    class Particle {
      constructor(x, y, vx, vy, color, life=500) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.color = color;
      }
      update() {
        this.x += this.vx * simulationSpeed;
        this.y += this.vy * simulationSpeed;
        this.life--;
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = Math.max(this.life / 500, 0.2);
        ctx.fillRect(this.x, this.y, 2, 2);
        ctx.globalAlpha = 1;
      }
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function drawGrid() {
      let step = 40;
      ctx.strokeStyle = "rgba(200,200,200,0.2)";
      ctx.lineWidth = 1;

      for (let x = 0; x < canvas.width; x += step) {
        ctx.beginPath();
        for (let y = 0; y <= canvas.height; y += step) {
          let [dx, dy] = distortPoint(x, y);
          if (y === 0) ctx.moveTo(dx, dy);
          else ctx.lineTo(dx, dy);
        }
        ctx.stroke();
      }

      for (let y = 0; y < canvas.height; y += step) {
        ctx.beginPath();
        for (let x = 0; x <= canvas.width; x += step) {
          let [dx, dy] = distortPoint(x, y);
          if (x === 0) ctx.moveTo(dx, dy);
          else ctx.lineTo(dx, dy);
        }
        ctx.stroke();
      }
    }

    function distortPoint(x, y) {
      let offsetX = 0, offsetY = 0;
      for (let obj of objects) {
        if (obj.type !== "blackhole") continue;
        let dx = x - obj.x;
        let dy = y - obj.y;
        let distSq = dx*dx + dy*dy;
        let dist = Math.sqrt(distSq);
        if (dist < 200) { // distortion radius
          let strength = (obj.radius * 200) / (distSq+1);
          offsetX += -dx / dist * strength;
          offsetY += -dy / dist * strength;
        }
      }
      return [x + offsetX, y + offsetY];
    }

    function updatePhysics() {
      const G = 0.1;
      for (let i = 0; i < objects.length; i++) {
        let a = objects[i];
        if (a.destroyed) continue;
        for (let j = i + 1; j < objects.length; j++) {
          let b = objects[j];
          if (b.destroyed) continue;

          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let distSq = dx * dx + dy * dy;
          let dist = Math.sqrt(distSq);
          if (dist < 1) continue;

          let force = (G * a.mass * b.mass) / distSq;
          let ax = (force / a.mass) * (dx / dist);
          let ay = (force / a.mass) * (dy / dist);
          let bx = (force / b.mass) * (-dx / dist);
          let by = (force / b.mass) * (-dy / dist);

          a.vx += ax * simulationSpeed;
          a.vy += ay * simulationSpeed;
          b.vx += bx * simulationSpeed;
          b.vy += by * simulationSpeed;

          // Spaghettification check
          if ((a.type !== "blackhole" && b.type === "blackhole") ||
              (b.type !== "blackhole" && a.type === "blackhole")) {
            let star = a.type === "blackhole" ? b : a;
            let bh = a.type === "blackhole" ? a : b;
            if (dist < bh.radius * 6) {
              // turn star into particles
              for (let k = 0; k < 10; k++) {
                let angle = Math.random() * Math.PI * 2;
                let speed = 1 + Math.random() * 2;
                particles.push(new Particle(
                  star.x, star.y,
                  Math.cos(angle) * speed, Math.sin(angle) * speed,
                  star.type === "star" ? "orange" : "lightblue"
                ));
              }
              star.mass *= 0.98;
              star.radius = Math.cbrt(star.mass) * 2;
              if (star.mass < 10) {
                star.destroyed = true;
                // Accretion disk
                for (let ang = 0; ang < Math.PI * 2; ang += 0.1) {
                  let distDisk = bh.radius * 3 + Math.random() * 20;
                  let px = bh.x + Math.cos(ang) * distDisk;
                  let py = bh.y + Math.sin(ang) * distDisk;
                  let tangentialSpeed = 2;
                  particles.push(new Particle(
                    px, py,
                    -Math.sin(ang) * tangentialSpeed,
                    Math.cos(ang) * tangentialSpeed,
                    "orange", 800
                  ));
                }
              }
            }
          }
        }
      }

      // update positions
      for (let obj of objects) {
        if (obj.destroyed) continue;
        obj.x += obj.vx * simulationSpeed;
        obj.y += obj.vy * simulationSpeed;
        // containment
        if (obj.x < obj.radius || obj.x > canvas.width - obj.radius) obj.vx *= -1;
        if (obj.y < obj.radius || obj.y > canvas.height - obj.radius) obj.vy *= -1;
      }

      for (let p of particles) p.update();
      particles = particles.filter(p => p.life > 0);
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      updatePhysics();
      for (let obj of objects) if (!obj.destroyed) obj.draw();
      for (let p of particles) p.draw();
      requestAnimationFrame(loop);
    }
    loop();

    // UI
    document.getElementById("addObject").onclick = () => {
      let type = document.getElementById("objectType").value;
      if (type === "blackhole")
        objects.push(new Body(canvas.width / 2, canvas.height / 2, 2000, "blackhole"));
      else if (type === "star")
        objects.push(new Body(Math.random() * canvas.width, Math.random() * canvas.height, 300, "star"));
      else
        objects.push(new Body(Math.random() * canvas.width, Math.random() * canvas.height, 80, "planet"));
    };
    document.getElementById("clear").onclick = () => {
      objects = [];
      particles = [];
    };
    document.getElementById("speed").oninput = (e) => (simulationSpeed = parseFloat(e.target.value));
  </script>
</body>
</html>
